# Algorithm

A collection of front-end algorithm exercises, with problems sourced from `LeetCode`

## KeyPoints

### String

- 欧几里得算法求最大公因数:`const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));`
- `双指针`利用`i/j`考虑左右情况进行判断
- 可以通过外层`let`设定一个写入的指针`writeIndex`,然后 for 循环内利用循环条件设定读取指针来实现`readIndex`双指针的形式,实现原地压缩
- `双指针`中需要注意所移动的指针,仅需移动短板指针

### Array

- 利用`Math.max()`直接寻找出数组中的最大值,无需遍历
- 利用`贪心算法`获得局部的最优解
- 利用`前缀积`实现从左到右/再从右到左的两次遍历实现相乘
- 利用`fill(0, index)`在指定索引后填充元素`0`
- 在针对配对问题,使用`双指针`可以先对数组进行一个排序`sort((a, b) => a - b)`
- 在`匹配对`的问题中,我们不仅可以使用双指针,还可以使用`哈希表(散列表)`来记录数字出现的次数,后续使用`map.get()`来进行获取和配对
- 在`子数组最大平均值`的问题中,可以先拆分问题 -> `求子数组最大和` -> `滑动窗口`,利用滑动窗口控制左右指针同时`+1`
- 在`滑动窗口`问题,我们可以先实现`第一次滑动窗口的计算`,后续再使用`右指针`对后续滑动窗口来计算
- 使用`不定长滑动窗口`时,一定要注意好判断条件,其中`双层循环嵌套`几乎是必须的
- 寻找`数组中心下标`的时候,需要关注`左侧和leftSum`和`右侧和rightSum`其中右侧和使用前缀和数组中来减去左侧和与自身的值

### Dynamic planning

-
